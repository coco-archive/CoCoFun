* 6809 assembly program generated by cmoc 0.1.15
	ORG	$2800		Code section
program_start	EQU	*
	LBSR	INILIB		initialize standard library and global variables
	LBSR	_main		call main()
	PSHS	B,A		send main() return value to exit()
	LBSR	_exit		use LBSR to respect calling convention
functions_start	EQU	*


*******************************************************************************

* FUNCTION anykey(): defined at Foo.c:88
_anykey	EQU	*
* Line Foo.c:89: if
	LDD	#$20		decimal 32 signed
	PSHS	B,A	
* Line Foo.c:89: function call: getTextMode()
	LBSR	_getTextMode
	CLRA			promotion of binary operand
	CMPD	,S++	
	BNE	L00109	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line Foo.c:90: function call: printf()
	LEAX	S00075,PCR	"PRESS ANY KEY TO CONTINUE... "
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
	BRA	L00110		jump over else clause
L00109	EQU	*	else
* Line Foo.c:92: function call: printf()
	LEAX	S00076,PCR	"Press any key to continue... "
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
L00110	EQU	*	end if
* Line Foo.c:93: function call: waitkey()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 1 of waitkey()
	LBSR	_waitkey
	LEAS	2,S	
* Useless label removed
	RTS


*******************************************************************************

* FUNCTION attr(): defined at /usr/local/share/cmoc/coco.h:233
_attr	EQU	*
	PSHS	U	
	LEAU	,S	
* Line /usr/local/share/cmoc/coco.h:235: if
	LDB	G00069+0,PCR	variable isCoCo3, declared at /usr/local/share/cmoc/coco.h:51
	TSTB
	BNE	L00112	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:236: return with value
	CLRA
	CLRB
	LBRA	L00043		return (/usr/local/share/cmoc/coco.h:236)
L00112	EQU	*	else
* Useless label removed
* Inline assembly:

        ldb     5,U
        lslb
        lslb
        lslb
        orb     7,U
        tst     9,U
        beq     attr_no_b
        orb     #$80
attr_no_b:
        tst     11,U
        beq     attr_no_u
        orb     #$40
attr_no_u:
        stb     $FE08
    
* End of inline assembly.
* Line /usr/local/share/cmoc/coco.h:256: return with value
	LDD	#$01		decimal 1 signed
* optim: branchToNextLocation
L00043	EQU	*	end of attr()
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION bsort(): defined at Foo.c:68
_bsort	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line Foo.c:70: for init
* Line Foo.c:70: assignment: =
	LDD	6,U	
	STD	-4,U	
	LBRA	L00115		jump to for condition
L00114	EQU	*
* Line Foo.c:70: for body
* Line Foo.c:71: init of variable c1
	LDX	4,U		pointer buffer
	LDD	-4,U		variable ii
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	STB	-5,U		variable c1
* Line Foo.c:72: for init
* Line Foo.c:72: assignment: =
	LDD	-4,U		variable ii
	ADDD	#$01		1
	STD	-2,U	
	BRA	L00119		jump to for condition
L00118	EQU	*
* Line Foo.c:72: for body
* Line Foo.c:73: init of variable c2
	LDX	4,U		pointer buffer
	LDD	-2,U		variable jj
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	STB	-6,U		variable c2
* Line Foo.c:74: if
* optim: storeLoad
	CMPB	-5,U		variable c1
	BHS	L00123	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line Foo.c:75: assignment: =
	LDX	4,U		pointer buffer
	LDD	-4,U		variable ii
	LEAX	D,X		add byte offset
	LDB	-6,U	
	STB	,X	
* Line Foo.c:76: assignment: =
	LDX	4,U		pointer buffer
	LDD	-2,U		variable jj
	LEAX	D,X		add byte offset
	LDB	-5,U	
	STB	,X	
* Line Foo.c:77: assignment: =
	LDB	-6,U	
	STB	-5,U	
L00123	EQU	*	else
* Useless label removed
* Useless label removed
* Line Foo.c:72: for increment(s)
	LDD	-2,U	
	ADDD	#1	
	STD	-2,U	
L00119	EQU	*
* Line Foo.c:72: for condition
	LDD	-2,U		variable jj
	CMPD	8,U		variable end
	BLT	L00118	
* optim: branchToNextLocation
* Useless label removed
* Useless label removed
* Line Foo.c:70: for increment(s)
	LDD	-4,U	
	ADDD	#1	
	STD	-4,U	
L00115	EQU	*
* Line Foo.c:70: for condition
	LDD	-4,U		variable ii
	CMPD	8,U		variable end
	LBLT	L00114	
* optim: branchToNextLocation
* Useless label removed
* Useless label removed
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION cls(): defined at /usr/local/share/cmoc/coco.h:197
_cls	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-1,S	
	PSHS	U,Y		/usr/local/share/cmoc/coco.h:199: inline asm
* Line /usr/local/share/cmoc/coco.h:201: if
	LDB	G00069+0,PCR	variable isCoCo3, declared at /usr/local/share/cmoc/coco.h:51
	TSTB
	BEQ	L00126	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:202: assignment: =
	LDB	$E7		decimal 231
	STB	-1,U	
	BRA	L00127		jump over else clause
L00126	EQU	*	else
* Line /usr/local/share/cmoc/coco.h:204: assignment: =
	CLRB
	STB	-1,U	
L00127	EQU	*	end if
* Line /usr/local/share/cmoc/coco.h:206: if
	LDB	-1,U		variable hrwidth, declared at /usr/local/share/cmoc/coco.h:200
	CMPB	#0	
	BEQ	L00129	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:208: if
	LDB	5,U		variable color
	CMPB	#$08	
	BLS	L00132	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:209: assignment: =
	LDB	#$01	
	STB	5,U	
L00132	EQU	*	else
* Useless label removed
	LDB	5,U		/usr/local/share/cmoc/coco.h:212: inline asm re: variable color
	JSR	$F6B8		/usr/local/share/cmoc/coco.h:213: inline asm
	BRA	L00130		jump over else clause
L00129	EQU	*	else
* Line /usr/local/share/cmoc/coco.h:215: if
	LDB	5,U		variable color
	CMPB	#$08	
	BLS	L00135	
* optim: condBranchOverUncondBranch
* Useless label removed
	JSR	$A928		/usr/local/share/cmoc/coco.h:217: inline asm
	BRA	L00136		jump over else clause
L00135	EQU	*	else
	LDB	5,U		/usr/local/share/cmoc/coco.h:221: inline asm re: variable color
	JSR	$A91C		/usr/local/share/cmoc/coco.h:222: inline asm
L00136	EQU	*	end if
L00130	EQU	*	end if
	PULS	Y,U		/usr/local/share/cmoc/coco.h:224: inline asm
* Useless label removed
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION getTextMode(): defined at /usr/local/share/cmoc/coco.h:180
_getTextMode	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-1,S	
* Line /usr/local/share/cmoc/coco.h:182: if
	LDB	G00069+0,PCR	variable isCoCo3, declared at /usr/local/share/cmoc/coco.h:51
	TSTB
	BEQ	L00138	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:184: init of variable hrWidth
	LDB	$E7		decimal 231
	STB	-1,U		variable hrWidth
* Line /usr/local/share/cmoc/coco.h:185: if
* optim: storeLoad
	CMPB	#$01	
	BNE	L00141	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:186: return with value
	LDD	#$28		decimal 40 signed
	BRA	L00041		return (/usr/local/share/cmoc/coco.h:186)
L00141	EQU	*	else
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:187: if
	LDB	-1,U		variable hrWidth
	CMPB	#$02	
	BNE	L00144	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:188: return with value
	LDD	#$50		decimal 80 signed
	BRA	L00041		return (/usr/local/share/cmoc/coco.h:188)
L00144	EQU	*	else
* Useless label removed
L00138	EQU	*	else
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:190: return with value
	LDD	#$20		decimal 32 signed
* optim: branchToNextLocation
L00041	EQU	*	end of getTextMode()
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION hscreen(): defined at /usr/local/share/cmoc/coco.h:295
_hscreen	EQU	*
	PSHS	U	
	LEAU	,S	
* Line /usr/local/share/cmoc/coco.h:297: if
	LDB	G00069+0,PCR	variable isCoCo3, declared at /usr/local/share/cmoc/coco.h:51
	TSTB
	BNE	L00147	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:298: return with value
	CLRA
	CLRB
	BRA	L00045		return (/usr/local/share/cmoc/coco.h:298)
L00147	EQU	*	else
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:300: if
	LDB	5,U		variable mode
	CMPB	#$04	
	BLS	L00150	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:301: return with value
	CLRA
	CLRB
	BRA	L00045		return (/usr/local/share/cmoc/coco.h:301)
L00150	EQU	*	else
* Useless label removed
	PSHS	U,Y		/usr/local/share/cmoc/coco.h:302: inline asm
	LDB	5,U		/usr/local/share/cmoc/coco.h:303: inline asm re: variable mode
	JSR	$E69C		/usr/local/share/cmoc/coco.h:304: inline asm
	PULS	Y,U		/usr/local/share/cmoc/coco.h:305: inline asm
* Line /usr/local/share/cmoc/coco.h:306: return with value
	LDD	#$01		decimal 1 signed
* optim: branchToNextLocation
L00045	EQU	*	end of hscreen()
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION hset(): defined at /usr/local/share/cmoc/coco.h:310
_hset	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-1,S	
* Line /usr/local/share/cmoc/coco.h:312: if
	LDD	4,U		variable x
	CMPD	#$0280	
	BHS	L00152	
* optim: branchToNextLocation
* Useless label removed
	LDD	6,U		variable y
	CMPD	#$C0	
	BHS	L00152	
* optim: branchToNextLocation
* Useless label removed
	LDB	9,U		variable color
	CMPB	#$10	
	BLO	L00153	
* optim: condBranchOverUncondBranch
L00152	EQU	*	then
* Line /usr/local/share/cmoc/coco.h:313: return with value
	CLRA
	CLRB
	LBRA	L00046		return (/usr/local/share/cmoc/coco.h:313)
L00153	EQU	*	else
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:314: init of variable hrmode
	LDB	$E6		decimal 230
	STB	-1,U		variable hrmode
* Line /usr/local/share/cmoc/coco.h:315: if
* optim: storeLoad
	CMPB	#0	
	BNE	L00158	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:316: return with value
	CLRA
	CLRB
	BRA	L00046		return (/usr/local/share/cmoc/coco.h:316)
L00158	EQU	*	else
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:317: if
	LDB	-1,U		variable hrmode
	CMPB	#$02	
	BHI	L00161	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:318: if
	LDD	4,U		variable x
	CMPD	#$0140	
	BLO	L00164	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:319: return with value
	CLRA
	CLRB
	BRA	L00046		return (/usr/local/share/cmoc/coco.h:319)
L00164	EQU	*	else
* Useless label removed
L00161	EQU	*	else
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:320: assignment: =
	LDB	#$01	
	STB	$C2	
* Line /usr/local/share/cmoc/coco.h:321: assignment: =
	LDD	4,U	
	STD	$BD	
* Line /usr/local/share/cmoc/coco.h:322: assignment: =
	LDD	6,U	
	STD	$BF	
	PSHS	U,Y		/usr/local/share/cmoc/coco.h:323: inline asm
	LDB	9,U		/usr/local/share/cmoc/coco.h:324: inline asm re: variable color
	JSR	$E73B		/usr/local/share/cmoc/coco.h:325: inline asm
	JSR	$E785		/usr/local/share/cmoc/coco.h:326: inline asm
	PULS	Y,U		/usr/local/share/cmoc/coco.h:327: inline asm
* Line /usr/local/share/cmoc/coco.h:328: return with value
	LDD	#$01		decimal 1 signed
* optim: branchToNextLocation
L00046	EQU	*	end of hset()
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION initCoCoSupport(): defined at /usr/local/share/cmoc/coco.h:56
_initCoCoSupport	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-2,S	
* Line /usr/local/share/cmoc/coco.h:58: init of variable irqServiceRoutineAddress
	LDD	$FFF8		decimal 65528
	STD	-2,U		variable irqServiceRoutineAddress
* Line /usr/local/share/cmoc/coco.h:59: assignment: =
* optim: storeLoad
	CMPD	#$FEF7	
	BEQ	L00166		if true
	CLRB
	BRA	L00167		false
L00166	EQU	*
	LDB	#1	
L00167	EQU	*
	STB	G00069+0,PCR
* Useless label removed
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION inkey(): defined at /usr/local/share/cmoc/coco.h:369
_inkey	EQU	*
* Inline assembly:

        jsr     [$A000]     
        tfr     a,b         
    
* End of inline assembly.
* Useless label removed
	RTS


*******************************************************************************

* FUNCTION main(): defined at Foo.c:254
_main	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-7,S	
* Line Foo.c:256: function call: initCoCoSupport()
	LBSR	_initCoCoSupport
* Line Foo.c:257: function call: setHighSpeed()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 1 of setHighSpeed()
	LBSR	_setHighSpeed
	LEAS	2,S	
* Line Foo.c:258: function call: setupCadnza()
	LBSR	_setupCadnza
* Line Foo.c:261: function call: width()
	LDD	#$20		decimal 32 signed
	PSHS	B,A		argument 1 of width()
	LBSR	_width	
	LEAS	2,S	
* Line Foo.c:262: function call: printf()
	LEAX	S00077,PCR	"********************************"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:263: function call: printf()
	LEAX	S00078,PCR	"*** WELCOME TO THE CMOC DEMO ***"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:264: function call: printf()
	LEAX	S00079,PCR	"********************************\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:265: function call: anykey()
	LBSR	_anykey	
* Line Foo.c:268: for init
* Line Foo.c:268: init of variable ii
	LDB	#$01		1
	STB	-5,U		variable ii
	LBRA	L00169		jump to for condition
L00168	EQU	*
* Line Foo.c:268: for body
* Line Foo.c:269: function call: width()
	LDA	#$28	
	LDB	-5,U	
	MUL			result of type byte in B
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of width()
	LBSR	_width	
	LEAS	2,S	
* Line Foo.c:270: function call: printf()
	LEAX	S00080,PCR	"*************************************\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:271: function call: printf()
	LDA	#$28	
	LDB	-5,U	
	MUL			result of type byte in B
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of printf()
	LEAX	S00081,PCR	"*** CMOC Supports %u column text! ***\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	4,S	
* Line Foo.c:272: function call: printf()
	LEAX	S00082,PCR	"*************************************\n\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:273: function call: printf()
	LEAX	S00083,PCR	"With fancy attributes such as "
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:274: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 2 of attr()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:275: function call: printf()
	LEAX	S00084,PCR	"C"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:276: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	LDD	#$03		decimal 3 signed
	PSHS	B,A		argument 2 of attr()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:277: function call: printf()
	LEAX	S00085,PCR	"O"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:278: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	LDD	#$04		decimal 4 signed
	PSHS	B,A		argument 2 of attr()
	LDD	#$03		decimal 3 signed
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:279: function call: printf()
	LEAX	S00086,PCR	"L"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:280: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	LDD	#$05		decimal 5 signed
	PSHS	B,A		argument 2 of attr()
	LDD	#$04		decimal 4 signed
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:281: function call: printf()
	LEAX	S00085,PCR	"O"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:282: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	LDD	#$06		decimal 6 signed
	PSHS	B,A		argument 2 of attr()
	LDD	#$05		decimal 5 signed
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:283: function call: printf()
	LEAX	S00087,PCR	"R"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:284: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:285: function call: printf()
	LEAX	S00088,PCR	",\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:286: function call: attr()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:287: function call: printf()
	LEAX	S00089,PCR	"Underline"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:288: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:289: function call: printf()
	LEAX	S00090,PCR	" and "
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:290: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 3 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:291: function call: printf()
	LEAX	S00091,PCR	"Blink"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:292: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:293: function call: printf()
	LEAX	S00092,PCR	"!\n\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:294: function call: printf()
	LEAX	S00093,PCR	"Combine attributes like so... "
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:295: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 3 of attr()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 2 of attr()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:296: function call: printf()
	LEAX	S00094,PCR	"U"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:297: function call: attr()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	LDD	#$03		decimal 3 signed
	PSHS	B,A		argument 2 of attr()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:298: function call: printf()
	LEAX	S00095,PCR	"G"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:299: function call: attr()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 4 of attr()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 3 of attr()
	LDD	#$04		decimal 4 signed
	PSHS	B,A		argument 2 of attr()
	LDD	#$03		decimal 3 signed
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:300: function call: printf()
	LEAX	S00086,PCR	"L"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:301: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 3 of attr()
	LDD	#$05		decimal 5 signed
	PSHS	B,A		argument 2 of attr()
	LDD	#$04		decimal 4 signed
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:302: function call: printf()
	LEAX	S00096,PCR	"Y"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:303: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	LDD	#$06		decimal 6 signed
	PSHS	B,A		argument 2 of attr()
	LDD	#$05		decimal 5 signed
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:304: function call: printf()
	LEAX	S00097,PCR	"!"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:305: function call: attr()
	CLRA
	CLRB
	PSHS	B,A		argument 4 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 3 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of attr()
	CLRA
	CLRB
	PSHS	B,A		argument 1 of attr()
	LBSR	_attr	
	LEAS	8,S	
* Line Foo.c:306: function call: printf()
	LEAX	S00098,PCR	"\nBut don\'t feel obligated to do that!\n\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:307: function call: anykey()
	LBSR	_anykey	
* Useless label removed
* Line Foo.c:268: for increment(s)
	INC	-5,U	
L00169	EQU	*
* Line Foo.c:268: for condition
	LDB	-5,U		variable ii
	CMPB	#$02	
	LBLS	L00168	
* optim: branchToNextLocation
* Useless label removed
* Line Foo.c:311: function call: width()
	LDD	#$20		decimal 32 signed
	PSHS	B,A		argument 1 of width()
	LBSR	_width	
	LEAS	2,S	
* Line Foo.c:312: for init
* Line Foo.c:312: init of variable ii
	CLR	-5,U		variable ii
	LBRA	L00173		jump to for condition
L00172	EQU	*
* Line Foo.c:312: for body
* Line Foo.c:314: function call: cls()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 1 of cls()
	LBSR	_cls	
	LEAS	2,S	
* Line Foo.c:315: function call: printf()
	LEAX	S00077,PCR	"********************************"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:316: function call: printf()
	LEAX	S00099,PCR	"*** BUBBLE SORT VERSUS QSORT ***"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:317: function call: printf()
	LEAX	S00079,PCR	"********************************\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:320: if
	LDB	-5,U		variable ii, declared at Foo.c:312
	CMPB	#0	
	BNE	L00177	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line Foo.c:321: function call: printf()
	LEAX	S00100,PCR	"PRESS A KEY TO SEE BUBBLE SORT "
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
	BRA	L00178		jump over else clause
L00177	EQU	*	else
* Line Foo.c:323: function call: printf()
	LEAX	S00101,PCR	"PRESS A KEY TO SEE QSORT "
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
L00178	EQU	*	end if
* Line Foo.c:324: function call: waitkey()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 1 of waitkey()
	LBSR	_waitkey
	LEAS	2,S	
* Line Foo.c:327: function call: printf()
	LEAX	S00102,PCR	"LOREM IPSUM DOLOR SIT AMET... "
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:328: function call: printf()
	LEAX	S00103,PCR	"THE QUICK BROWN FOX JUMPED OVER\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:329: function call: printf()
	LEAX	S00104,PCR	"THE LAZY TYPIST\n\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:332: init of variable buffer
	LDD	#$0400		1024
	STD	-7,U		variable buffer
* Line Foo.c:333: if
	LDB	-5,U		variable ii, declared at Foo.c:312
	CMPB	#0	
	BNE	L00180	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line Foo.c:334: function call: bsort()
	LDD	#$0200		decimal 512 signed
	PSHS	B,A		argument 3 of bsort()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of bsort()
	LDD	-7,U		variable buffer, declared at Foo.c:332
	PSHS	B,A		argument 1 of bsort()
	LBSR	_bsort	
	LEAS	6,S	
	BRA	L00181		jump over else clause
L00180	EQU	*	else
* Line Foo.c:336: function call: qsort2()
	LDD	#$01FF		constant expression: 511 decimal
	PSHS	B,A		argument 3 of qsort2()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of qsort2()
	LDD	-7,U		variable buffer, declared at Foo.c:332
	PSHS	B,A		argument 1 of qsort2()
	LBSR	_qsort2	
	LEAS	6,S	
L00181	EQU	*	end if
* Line Foo.c:337: function call: anykey()
	LBSR	_anykey	
* Useless label removed
* Line Foo.c:312: for increment(s)
	INC	-5,U	
L00173	EQU	*
* Line Foo.c:312: for condition
	LDB	-5,U		variable ii
	CMPB	#$02	
	LBLO	L00172	
* optim: branchToNextLocation
* Useless label removed
* Line Foo.c:341: function call: cls()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 1 of cls()
	LBSR	_cls	
	LEAS	2,S	
* Line Foo.c:342: function call: printf()
	LEAX	S00077,PCR	"********************************"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:343: function call: printf()
	LEAX	S00105,PCR	"***  HIRES GRAPHICS SCREENS  ***"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:344: function call: printf()
	LEAX	S00079,PCR	"********************************\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:345: function call: anykey()
	LBSR	_anykey	
* Line Foo.c:346: function call: hscreen()
	LDD	#$04		decimal 4 signed
	PSHS	B,A		argument 1 of hscreen()
	LBSR	_hscreen
	LEAS	2,S	
* Line Foo.c:348: for init
* Line Foo.c:348: assignment: =
	CLRB
	CLRA
	STD	-4,U	
	BRA	L00183		jump to for condition
L00182	EQU	*
* Line Foo.c:348: for body
* Line Foo.c:349: function call: hset()
	LDD	-4,U		variable xx
	ANDA	#$00	
	ANDB	#$03	
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of hset()
	CLRA
	CLRB
	PSHS	B,A		argument 2 of hset()
	LDD	-4,U		variable xx, declared at Foo.c:347
	PSHS	B,A		argument 1 of hset()
	LBSR	_hset	
	LEAS	6,S	
* Line Foo.c:350: function call: hset()
	LDD	-4,U		variable xx
	ANDA	#$00	
	ANDB	#$03	
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of hset()
	LDD	#$BF		decimal 191 signed
	PSHS	B,A		argument 2 of hset()
	LDD	-4,U		variable xx, declared at Foo.c:347
	PSHS	B,A		argument 1 of hset()
	LBSR	_hset	
	LEAS	6,S	
* Useless label removed
* Line Foo.c:348: for increment(s)
	LDD	-4,U	
	ADDD	#1	
	STD	-4,U	
L00183	EQU	*
* Line Foo.c:348: for condition
	LDD	-4,U		variable xx
	CMPD	#$0280	
	LBLO	L00182	
* optim: branchToNextLocation
* Useless label removed
* Line Foo.c:352: for init
* Line Foo.c:352: assignment: =
	CLRB
	CLRA
	STD	-2,U	
	BRA	L00187		jump to for condition
L00186	EQU	*
* Line Foo.c:352: for body
* Line Foo.c:353: function call: hset()
	LDD	-2,U		variable yy
	ANDA	#$00	
	ANDB	#$03	
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of hset()
	LDD	-2,U		variable yy, declared at Foo.c:347
	PSHS	B,A		argument 2 of hset()
	CLRA
	CLRB
	PSHS	B,A		argument 1 of hset()
	LBSR	_hset	
	LEAS	6,S	
* Line Foo.c:354: function call: hset()
	LDD	-2,U		variable yy
	ANDA	#$00	
	ANDB	#$03	
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of hset()
	LDD	-2,U		variable yy, declared at Foo.c:347
	PSHS	B,A		argument 2 of hset()
	LDD	#$027F		decimal 639 signed
	PSHS	B,A		argument 1 of hset()
	LBSR	_hset	
	LEAS	6,S	
* Useless label removed
* Line Foo.c:352: for increment(s)
	LDD	-2,U	
	ADDD	#1	
	STD	-2,U	
L00187	EQU	*
* Line Foo.c:352: for condition
	LDD	-2,U		variable yy
	CMPD	#$C0	
	LBLO	L00186	
* optim: branchToNextLocation
* Useless label removed
* Line Foo.c:356: for init
* Line Foo.c:356: assignment: =
	CLRB
	CLRA
	STD	-4,U	
	LBRA	L00191		jump to for condition
L00190	EQU	*
* Line Foo.c:356: for body
* Line Foo.c:357: function call: hset()
	LDD	-4,U		variable xx
	ANDA	#$00	
	ANDB	#$03	
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of hset()
	LDD	#$01		decimal 1 signed
	PSHS	B,A	
	LDD	-4,U		variable xx
	ADDD	#$01		1
	PSHS	B,A	
	LDD	#$64		decimal 100 signed
	PULS	X	
	LBSR	MUL16	
	PSHS	B,A	
	LDD	#$014D		decimal 333 signed
	PULS	X	
	LBSR	DIV16	
	TFR	X,D		quotient
	SUBD	,S++	
	PSHS	B,A		argument 2 of hset()
	LDD	-4,U		variable xx, declared at Foo.c:347
	PSHS	B,A		argument 1 of hset()
	LBSR	_hset	
	LEAS	6,S	
* Line Foo.c:358: function call: hset()
	LDD	-4,U		variable xx
	ANDA	#$00	
	ANDB	#$03	
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of hset()
	LDD	#$01		decimal 1 signed
	PSHS	B,A	
	LDD	-4,U		variable xx
	ADDD	#$01		1
	PSHS	B,A	
	LDD	#$64		decimal 100 signed
	PULS	X	
	LBSR	MUL16	
	PSHS	B,A	
	LDD	#$014D		decimal 333 signed
	PULS	X	
	LBSR	DIV16	
	TFR	X,D		quotient
	SUBD	,S++	
	PSHS	B,A	
	LDD	#$BF		decimal 191 signed
	SUBD	,S++	
	PSHS	B,A		argument 2 of hset()
	LDD	-4,U		variable xx, declared at Foo.c:347
	PSHS	B,A		argument 1 of hset()
	LBSR	_hset	
	LEAS	6,S	
* Useless label removed
* Line Foo.c:356: for increment(s)
	LDD	-4,U	
	ADDD	#1	
	STD	-4,U	
L00191	EQU	*
* Line Foo.c:356: for condition
	LDD	-4,U		variable xx
	CMPD	#$0280	
	LBLO	L00190	
* optim: branchToNextLocation
* Useless label removed
* Line Foo.c:360: function call: anykey()
	LBSR	_anykey	
* Line Foo.c:361: function call: hscreen()
	CLRA
	CLRB
	PSHS	B,A		argument 1 of hscreen()
	LBSR	_hscreen
	LEAS	2,S	
* Line Foo.c:364: function call: cls()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 1 of cls()
	LBSR	_cls	
	LEAS	2,S	
* Line Foo.c:365: function call: printf()
	LEAX	S00077,PCR	"********************************"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:366: function call: printf()
	LEAX	S00106,PCR	"***    PLAY AWESOME SONGS    ***"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:367: function call: printf()
	LEAX	S00079,PCR	"********************************\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:368: function call: setHighSpeed()
	CLRA
	CLRB
	PSHS	B,A		argument 1 of setHighSpeed()
	LBSR	_setHighSpeed
	LEAS	2,S	
* Line Foo.c:369: function call: playCadnza()
	LBSR	_playCadnza
* Line Foo.c:372: function call: cls()
	LDD	#$01		decimal 1 signed
	PSHS	B,A		argument 1 of cls()
	LBSR	_cls	
	LEAS	2,S	
* Line Foo.c:373: function call: printf()
	LEAX	S00077,PCR	"********************************"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:374: function call: printf()
	LEAX	S00107,PCR	"***   HAVE FUN USING CMOC!   ***"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:375: function call: printf()
	LEAX	S00079,PCR	"********************************\n"
	PSHS	X		argument 1 of printf()
	LBSR	_printf	
	LEAS	2,S	
* Line Foo.c:377: return with value
	CLRA
	CLRB
* optim: branchToNextLocation
* Useless label removed
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION playCadnza(): defined at Foo.c:203
_playCadnza	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-6,S	
* Line Foo.c:205: init of variable n
	LDD	#$04		4
	STD	-6,U		variable n
* Line Foo.c:206: init of variable s
	LDB	#$04		4
	STB	-4,U		variable s
* Line Foo.c:207: init of variable c
	CLR	-3,U		variable c
* Line Foo.c:208: function call: playChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playChord()
	LBSR	_playChord
	LEAS	6,S	
* Line Foo.c:209: assignment: =
	LDB	#$05	
	STB	-3,U	
* Line Foo.c:209: function call: playChord()
* optim: storeLoad
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playChord()
	LBSR	_playChord
	LEAS	6,S	
* Line Foo.c:210: assignment: =
	LDB	#$04	
	STB	-3,U	
* Line Foo.c:210: assignment: =
	LDD	#$02	
	STD	-6,U	
* Line Foo.c:210: function call: playChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playChord()
	LBSR	_playChord
	LEAS	6,S	
* Line Foo.c:211: function call: sound()
	LDD	#$04		decimal 4 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$4E		decimal 78 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:211: function call: sound()
	LDD	#$04		decimal 4 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$7D		decimal 125 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:212: function call: sound()
	LDD	#$04		decimal 4 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$93		decimal 147 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:212: function call: sound()
	LDD	#$04		decimal 4 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$9F		decimal 159 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:213: assignment: =
	LDB	#$02	
	STB	-3,U	
* Line Foo.c:213: assignment: =
	LDD	#$01	
	STD	-6,U	
* Line Foo.c:213: function call: playChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playChord()
	LBSR	_playChord
	LEAS	6,S	
* Line Foo.c:216: assignment: =
	LDD	#$04	
	STD	-6,U	
* Line Foo.c:217: assignment: =
	CLRB
	STB	-3,U	
* Line Foo.c:217: assignment: =
	LDB	#$02	
	STB	-4,U	
* Line Foo.c:217: init of variable nt
	CLRA
	CLRB
	STD	-2,U		variable nt
* Line Foo.c:217: function call: playMelodyAndChord()
* optim: storeLoad
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:218: assignment: =
	LDB	#$05	
	STB	-3,U	
* Line Foo.c:218: assignment: =
	CLRB
	CLRA
	STD	-2,U	
* Line Foo.c:218: function call: playMelodyAndChord()
* optim: storeLoad
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:219: assignment: =
	CLRB
	STB	-3,U	
* Line Foo.c:219: assignment: =
	CLRB
	CLRA
	STD	-2,U	
* Line Foo.c:219: function call: playMelodyAndChord()
* optim: storeLoad
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:220: assignment: =
	LDB	#$05	
	STB	-3,U	
* Line Foo.c:220: assignment: =
	CLRB
	CLRA
	STD	-2,U	
* Line Foo.c:220: function call: playMelodyAndChord()
* optim: storeLoad
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:221: assignment: =
	LDB	#$04	
	STB	-3,U	
* Line Foo.c:221: assignment: =
	LDD	#$02	
	STD	-6,U	
* Line Foo.c:221: assignment: =
	LDD	#$07	
	STD	-2,U	
* Line Foo.c:221: function call: playMelodyAndChord()
* optim: storeLoad
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:222: function call: sound()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$4E		decimal 78 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:222: function call: sound()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$AA		decimal 170 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:223: function call: sound()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$7D		decimal 125 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:223: function call: sound()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$C1		decimal 193 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:224: function call: sound()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$93		decimal 147 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:224: function call: sound()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$CC		decimal 204 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:225: function call: sound()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$9F		decimal 159 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:225: function call: sound()
	LDD	#$02		decimal 2 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$D2		decimal 210 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:226: assignment: =
	LDD	#$07	
	STD	-2,U	
* Line Foo.c:226: assignment: =
	LDB	#$02	
	STB	-3,U	
* Line Foo.c:226: assignment: =
	LDD	#$01	
	STD	-6,U	
* Line Foo.c:226: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:227: assignment: =
	LDB	#$01	
	STB	-4,U	
* Line Foo.c:228: assignment: =
	LDD	#$08	
	STD	-6,U	
* Line Foo.c:228: assignment: =
	CLRB
	CLRA
	STD	-2,U	
* Line Foo.c:228: assignment: =
	CLRB
	STB	-3,U	
* Line Foo.c:229: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:230: assignment: =
	LDB	#$05	
	STB	-3,U	
* Line Foo.c:230: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:231: assignment: =
	CLRB
	CLRA
	STD	-2,U	
* Line Foo.c:232: assignment: =
	CLRB
	STB	-3,U	
* Line Foo.c:232: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:233: assignment: =
	LDB	#$05	
	STB	-3,U	
* Line Foo.c:233: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:234: assignment: =
	CLRB
	CLRA
	STD	-2,U	
* Line Foo.c:235: assignment: =
	LDB	#$04	
	STB	-3,U	
* Line Foo.c:235: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:236: assignment: =
	CLRB
	CLRA
	STD	-2,U	
* Line Foo.c:237: function call: playMelodyAndChord()
* optim: storeLoad
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:238: assignment: =
	CLRB
	STB	-3,U	
* Line Foo.c:238: assignment: =
	LDD	#$04	
	STD	-6,U	
* Line Foo.c:238: assignment: =
	CLRB
	CLRA
	STD	-2,U	
* Line Foo.c:238: function call: playMelodyAndChord()
* optim: storeLoad
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:239: assignment: =
	LDB	#$03	
	STB	-3,U	
* Line Foo.c:239: assignment: =
	LDD	#$02	
	STD	-6,U	
* Line Foo.c:239: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:240: assignment: =
	LDB	#$04	
	STB	-3,U	
* Line Foo.c:240: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:241: assignment: =
	CLRB
	STB	-3,U	
* Line Foo.c:241: assignment: =
	LDD	#$04	
	STD	-6,U	
* Line Foo.c:241: assignment: =
	CLRB
	CLRA
	STD	-2,U	
* Line Foo.c:241: function call: playMelodyAndChord()
* optim: storeLoad
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:242: assignment: =
	LDB	#$03	
	STB	-3,U	
* Line Foo.c:242: assignment: =
	LDD	#$02	
	STD	-6,U	
* Line Foo.c:242: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:243: assignment: =
	LDB	#$04	
	STB	-3,U	
* Line Foo.c:243: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:244: assignment: =
	LDB	#$05	
	STB	-3,U	
* Line Foo.c:244: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:245: assignment: =
	LDB	#$06	
	STB	-3,U	
* Line Foo.c:245: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:246: assignment: =
	CLRB
	CLRA
	STD	-2,U	
* Line Foo.c:247: assignment: =
	LDB	#$07	
	STB	-3,U	
* Line Foo.c:247: assignment: =
	LDD	#$08	
	STD	-6,U	
* Line Foo.c:247: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:248: assignment: =
	CLRB
	CLRA
	STD	-2,U	
* Line Foo.c:249: assignment: =
	LDB	#$08	
	STB	-4,U	
* Line Foo.c:249: assignment: =
	LDD	#$01	
	STD	-6,U	
* Line Foo.c:249: function call: playMelodyAndChord()
	LDD	-2,U		variable nt, declared at Foo.c:217
	PSHS	B,A		argument 4 of playMelodyAndChord()
	LDB	-3,U		variable c, declared at Foo.c:207
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 3 of playMelodyAndChord()
	LDB	-4,U		variable s, declared at Foo.c:206
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of playMelodyAndChord()
	LDD	-6,U		variable n, declared at Foo.c:205
	PSHS	B,A		argument 1 of playMelodyAndChord()
	LBSR	_playMelodyAndChord
	LEAS	8,S	
* Line Foo.c:250: function call: sound()
	LDD	#$20		decimal 32 signed
	PSHS	B,A		argument 2 of sound()
	LDD	#$7D		decimal 125 signed
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Useless label removed
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION playChord(): defined at Foo.c:166
_playChord	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-4,S	
* Line Foo.c:167: for init
* Line Foo.c:167: init of variable n1
	CLRA
	CLRB
	STD	-2,U		variable n1
	LBRA	L00195		jump to for condition
L00194	EQU	*
* Line Foo.c:167: for body
* Line Foo.c:168: for init
* Line Foo.c:168: init of variable n2
	CLRA
	CLRB
	STD	-4,U		variable n2
	BRA	L00199		jump to for condition
L00198	EQU	*
* Line Foo.c:168: for body
* Line Foo.c:168: function call: sound()
	LDB	7,U		variable s, declared at Foo.c:166
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of sound()
	LEAX	G00073+0,PCR	address of array cd
	LDD	8,U		variable c
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	-4,U		variable n2
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Useless label removed
* Line Foo.c:168: for increment(s)
	LDD	-4,U	
	ADDD	#1	
	STD	-4,U	
L00199	EQU	*
* Line Foo.c:168: for condition
	LDD	-4,U		variable n2
	CMPD	#$04	
	BLT	L00198	
* optim: branchToNextLocation
* Useless label removed
* Useless label removed
* Line Foo.c:167: for increment(s)
	LDD	-2,U	
	ADDD	#1	
	STD	-2,U	
L00195	EQU	*
* Line Foo.c:167: for condition
	LDD	-2,U		variable n1
	CMPD	4,U		variable n
	LBLT	L00194	
* optim: branchToNextLocation
* Useless label removed
* Useless label removed
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION playMelodyAndChord(): defined at Foo.c:184
_playMelodyAndChord	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-4,S	
* Line Foo.c:185: if
	CLRA
	CLRB
	PSHS	B,A	
	LEAX	G00074+0,PCR	address of array md
	LDD	10,U		variable nt
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	CMPD	,S++	
	BHI	L00203	
* optim: condBranchOverUncondBranch
* Useless label removed
	LBRA	L00065		return (Foo.c:185)
L00203	EQU	*	else
* Useless label removed
* Line Foo.c:186: for init
* Line Foo.c:186: init of variable n1
	CLRA
	CLRB
	STD	-2,U		variable n1
	LBRA	L00206		jump to for condition
L00205	EQU	*
* Line Foo.c:186: for body
* Line Foo.c:187: for init
* Line Foo.c:187: init of variable n2
	CLRA
	CLRB
	STD	-4,U		variable n2
	LBRA	L00210		jump to for condition
L00209	EQU	*
* Line Foo.c:187: for body
* Line Foo.c:188: function call: sound()
	LDB	7,U		variable s, declared at Foo.c:184
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of sound()
	LEAX	G00074+0,PCR	address of array md
	LDD	10,U		variable nt
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
	LEAX	10,U		variable nt, declared at Foo.c:184
	LDD	,X	
	ADDD	#1	
	STD	,X	
	SUBD	#1		post increment yields initial value
* Line Foo.c:189: function call: sound()
	LDB	7,U		variable s, declared at Foo.c:184
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 2 of sound()
	LEAX	G00073+0,PCR	address of array cd
	LDD	8,U		variable c
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	-4,U		variable n2
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	CLRA			promoting byte argument to word
	PSHS	B,A		argument 1 of sound()
	LBSR	_sound	
	LEAS	4,S	
* Line Foo.c:190: if
	CLRA
	CLRB
	PSHS	B,A	
	LEAX	G00074+0,PCR	address of array md
	LDD	10,U		variable nt
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	CMPD	,S++	
	BHI	L00214	
* optim: condBranchOverUncondBranch
* Useless label removed
	BRA	L00065		return (Foo.c:190)
L00214	EQU	*	else
* Useless label removed
* Useless label removed
* Line Foo.c:187: for increment(s)
	LDD	-4,U	
	ADDD	#1	
	STD	-4,U	
L00210	EQU	*
* Line Foo.c:187: for condition
	LDD	-4,U		variable n2
	CMPD	#$04	
	LBLT	L00209	
* optim: branchToNextLocation
* Useless label removed
* Useless label removed
* Line Foo.c:186: for increment(s)
	LDD	-2,U	
	ADDD	#1	
	STD	-2,U	
L00206	EQU	*
* Line Foo.c:186: for condition
	LDD	-2,U		variable n1
	CMPD	4,U		variable n
	LBLT	L00205	
* optim: branchToNextLocation
* Useless label removed
L00065	EQU	*	end of playMelodyAndChord()
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION qsort2(): defined at Foo.c:28
_qsort2	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-7,S	
* Line Foo.c:32: if
	LDD	6,U		variable low
	CMPD	8,U		variable high
	LBGE	L00217	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line Foo.c:33: assignment: =
	LDD	6,U	
	STD	-7,U	
* Line Foo.c:34: assignment: =
	LDD	6,U	
	STD	-3,U	
* Line Foo.c:35: assignment: =
	LDD	8,U	
	STD	-5,U	
* Line Foo.c:37: while
L00220	EQU	*	while condition at Foo.c:37
	LDD	-3,U		variable i
	CMPD	-5,U		variable j
	LBGE	L00221	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line Foo.c:38: while
L00223	EQU	*	while condition at Foo.c:38
	LDX	4,U		pointer arr
	LDD	-7,U		variable pivot
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	PSHS	B,A	
	LDX	4,U		pointer arr
	LDD	-3,U		variable i
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	LEAS	1,S		disregard MSB
	CMPB	,S+		compare with LSB
	BHI	L00224	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDD	-3,U		variable i
	CMPD	8,U		variable high
	BGE	L00224	
* optim: condBranchOverUncondBranch
* Useless label removed
	LEAX	-3,U		variable i, declared at Foo.c:29
	LDD	,X	
	ADDD	#1	
	STD	,X	
	SUBD	#1		post increment yields initial value
	BRA	L00223		go to while condition
L00224	EQU	*	after end of while starting at Foo.c:38
* Line Foo.c:42: while
L00227	EQU	*	while condition at Foo.c:42
	LDX	4,U		pointer arr
	LDD	-7,U		variable pivot
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	PSHS	B,A	
	LDX	4,U		pointer arr
	LDD	-5,U		variable j
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	LEAS	1,S		disregard MSB
	CMPB	,S+		compare with LSB
	BLS	L00228	
* optim: condBranchOverUncondBranch
* Useless label removed
	LEAX	-5,U		variable j, declared at Foo.c:29
	LDD	,X	
	SUBD	#1	
	STD	,X	
	ADDD	#1		post increment yields initial value
	BRA	L00227		go to while condition
L00228	EQU	*	after end of while starting at Foo.c:42
* Line Foo.c:46: if
	LDD	-3,U		variable i
	CMPD	-5,U		variable j
	BGE	L00230	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line Foo.c:47: assignment: =
	LDX	4,U		pointer arr
	LDD	-3,U		variable i
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	STB	-1,U	
* Line Foo.c:48: assignment: =
	LDX	4,U		pointer arr
	LDD	-5,U		variable j
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	PSHS	B	
	LDX	4,U		pointer arr
	LDD	-3,U		variable i
	LEAX	D,X		add byte offset
	LDB	,S+	
	STB	,X	
* Line Foo.c:49: assignment: =
	LDX	4,U		pointer arr
	LDD	-5,U		variable j
	LEAX	D,X		add byte offset
	LDB	-1,U	
	STB	,X	
L00230	EQU	*	else
* Useless label removed
	LBRA	L00220		go to while condition
L00221	EQU	*	after end of while starting at Foo.c:37
* Line Foo.c:53: assignment: =
	LDX	4,U		pointer arr
	LDD	-7,U		variable pivot
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	STB	-1,U	
* Line Foo.c:54: assignment: =
	LDX	4,U		pointer arr
	LDD	-5,U		variable j
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	PSHS	B	
	LDX	4,U		pointer arr
	LDD	-7,U		variable pivot
	LEAX	D,X		add byte offset
	LDB	,S+	
	STB	,X	
* Line Foo.c:55: assignment: =
	LDX	4,U		pointer arr
	LDD	-5,U		variable j
	LEAX	D,X		add byte offset
	LDB	-1,U	
	STB	,X	
* Line Foo.c:56: function call: qsort2()
	LDD	-5,U		variable j
	ADDD	#$FFFF		65535
	PSHS	B,A		argument 3 of qsort2()
	LDD	6,U		variable low, declared at Foo.c:28
	PSHS	B,A		argument 2 of qsort2()
	LDD	4,U		variable arr, declared at Foo.c:28
	PSHS	B,A		argument 1 of qsort2()
	LBSR	_qsort2	
	LEAS	6,S	
* Line Foo.c:57: function call: qsort2()
	LDD	8,U		variable high, declared at Foo.c:28
	PSHS	B,A		argument 3 of qsort2()
	LDD	-5,U		variable j
	ADDD	#$01		1
	PSHS	B,A		argument 2 of qsort2()
	LDD	4,U		variable arr, declared at Foo.c:28
	PSHS	B,A		argument 1 of qsort2()
	LBSR	_qsort2	
	LEAS	6,S	
L00217	EQU	*	else
* Useless label removed
* Useless label removed
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION readArrays(): defined at Foo.c:145
_readArrays	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-8,S	
* Line Foo.c:146: init of variable dataIndex
	CLRA
	CLRB
	STD	-4,U		variable dataIndex
* Line Foo.c:147: for init
* Line Foo.c:147: init of variable ii
	CLRA
	CLRB
	STD	-6,U		variable ii
	LBRA	L00233		jump to for condition
L00232	EQU	*
* Line Foo.c:147: for body
* Line Foo.c:148: for init
* Line Foo.c:148: init of variable jj
	CLRA
	CLRB
	STD	-8,U		variable jj
	BRA	L00237		jump to for condition
L00236	EQU	*
* Line Foo.c:148: for body
* Line Foo.c:149: assignment: =
	LEAX	G00072+0,PCR	address of array data
	LDD	-4,U		variable dataIndex
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	PSHS	B	
	LEAX	G00073+0,PCR	address of array cd
	LDD	-6,U		variable ii
	LSLB
	ROLA
	LSLB
	ROLA
	LEAX	D,X		add byte offset
	LDD	-8,U		variable jj
	LEAX	D,X		add byte offset
	LDB	,S+	
	STB	,X	
* Useless label removed
* Line Foo.c:148: for increment(s)
	LEAX	-8,U		variable jj, declared at Foo.c:148
	LDD	,X	
	ADDD	#1	
	STD	,X	
	SUBD	#1		post increment yields initial value
	LEAX	-4,U		variable dataIndex, declared at Foo.c:146
	LDD	,X	
	ADDD	#1	
	STD	,X	
	SUBD	#1		post increment yields initial value
L00237	EQU	*
* Line Foo.c:148: for condition
	LDD	-8,U		variable jj
	CMPD	#$04	
	LBLT	L00236	
* optim: branchToNextLocation
* Useless label removed
* Useless label removed
* Line Foo.c:147: for increment(s)
	LDD	-6,U	
	ADDD	#1	
	STD	-6,U	
L00233	EQU	*
* Line Foo.c:147: for condition
	LDD	-6,U		variable ii
	CMPD	#$08	
	LBLT	L00232	
* optim: branchToNextLocation
* Useless label removed
* Line Foo.c:153: init of variable ii
	CLRA
	CLRB
	STD	-2,U		variable ii
* Line Foo.c:156: do-while
L00240	EQU	*	do-while body
* Line Foo.c:155: assignment: =
	LEAX	G00072+0,PCR	address of array data
	PSHS	X		preserve array address, then eval array index
	LEAX	-4,U		variable dataIndex, declared at Foo.c:146
	LDD	,X	
	ADDD	#1	
	STD	,X	
	SUBD	#1		post increment yields initial value
	PULS	X		retrieve array address
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	PSHS	B	
	LEAX	G00074+0,PCR	address of array md
	LDD	-2,U		variable ii
	LEAX	D,X		add byte offset
	LDB	,S+	
	STB	,X	
* Useless label removed
	CLRA
	CLRB
	PSHS	B,A	
	LEAX	G00074+0,PCR	address of array md
	PSHS	X		preserve array address, then eval array index
	LEAX	-2,U		variable ii, declared at Foo.c:153
	LDD	,X	
	ADDD	#1	
	STD	,X	
	SUBD	#1		post increment yields initial value
	PULS	X		retrieve array address
	LEAX	D,X		add byte offset
	LDB	,X		get r-value
	CLRA			promotion of binary operand
	CMPD	,S++	
	LBHI	L00240	
	BRA	L00242	
* optim: instrFollowingUncondBranch
L00242	EQU	*	after end of do-while starting at Foo.c:156
* Useless label removed
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION setHighSpeed(): defined at /usr/local/share/cmoc/coco.h:63
_setHighSpeed	EQU	*
	PSHS	U	
	LEAU	,S	
* Inline assembly:

        ldx     #65494
        tst     5,U
        beq     setHighSpeed_010
        leax    1,x
setHighSpeed_010:
        tst     G00069+0,PCR
        beq     setHighSpeed_020
        leax    2,x
setHighSpeed_020:
        clr     ,x
    
* End of inline assembly.
* Useless label removed
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION setSAMRegisters(): defined at /usr/local/share/cmoc/coco.h:493
_setSAMRegisters	EQU	*
	PSHS	U	
	LEAU	,S	
* Line /usr/local/share/cmoc/coco.h:495: while
L00244	EQU	*	while condition at /usr/local/share/cmoc/coco.h:495
	LDB	9,U		variable numBits, declared at /usr/local/share/cmoc/coco.h:493
	TSTB
	BEQ	L00245	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:499: assignment: =
	LDB	7,U		variable value
	ANDB	#$01	
	CLRA			promotion of binary operand
	ADDD	4,U		optim: pushDLoadAdd
* 
* 
	TFR	D,X	
	CLRB
	STB	,X	
* Line /usr/local/share/cmoc/coco.h:501: assignment: =
	LDB	7,U		variable value, declared at /usr/local/share/cmoc/coco.h:493
	LSRB
	STB	7,U	
	LEAX	9,U		variable numBits, declared at /usr/local/share/cmoc/coco.h:493
	DEC	,X	
	LDB	,X	
* Line /usr/local/share/cmoc/coco.h:507: assignment: +=
	LDD	4,U		variable samAddr
	ADDD	#$02		+= operator at /usr/local/share/cmoc/coco.h:507
	STD	4,U	
	BRA	L00244		go to while condition
L00245	EQU	*	after end of while starting at /usr/local/share/cmoc/coco.h:495
* Useless label removed
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION setupCadnza(): defined at Foo.c:196
_setupCadnza	EQU	*
* Line Foo.c:198: function call: readArrays()
	LBSR	_readArrays
* Useless label removed
	RTS


*******************************************************************************

* FUNCTION sound(): defined at /usr/local/share/cmoc/coco.h:405
_sound	EQU	*
	PSHS	U	
	LEAU	,S	
	PSHS	U		/usr/local/share/cmoc/coco.h:407: inline asm
* Line /usr/local/share/cmoc/coco.h:408: assignment: =
	LDB	5,U	
	STB	$8C	
* Line /usr/local/share/cmoc/coco.h:409: assignment: =
	LDB	7,U		variable duration, declared at /usr/local/share/cmoc/coco.h:405
	CLRA			cast from byte
	LSLB
	ROLA
	LSLB
	ROLA
* optim: pushDLoadXLoadD
	LDX	#$8D		decimal 141
* 
	STD	,X	
	JSR	$A956		/usr/local/share/cmoc/coco.h:410: inline asm
	PULS	U		/usr/local/share/cmoc/coco.h:411: inline asm
* Useless label removed
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION waitkey(): defined at /usr/local/share/cmoc/coco.h:381
_waitkey	EQU	*
	PSHS	U	
	LEAU	,S	
	LEAS	-1,S	
* Line /usr/local/share/cmoc/coco.h:384: if
	LDB	5,U		variable blinkCursor, declared at /usr/local/share/cmoc/coco.h:381
	TSTB
	LBEQ	L00247	
* optim: condBranchOverUncondBranch
* Useless label removed
* Inline assembly:

            jsr $A1B1  
            sta -1,U
        
* End of inline assembly.
* Line /usr/local/share/cmoc/coco.h:391: return with value
	LDB	-1,U		variable key, declared at /usr/local/share/cmoc/coco.h:383
	BRA	L00050		return (/usr/local/share/cmoc/coco.h:391)
L00247	EQU	*	else
* Useless label removed
L00249	EQU	*
* Line /usr/local/share/cmoc/coco.h:394: for body
* Line /usr/local/share/cmoc/coco.h:396: assignment: =
* Line /usr/local/share/cmoc/coco.h:396: function call: inkey()
	LBSR	_inkey	
	STB	-1,U	
* Line /usr/local/share/cmoc/coco.h:397: if
* optim: storeLoad
	TSTB
	BEQ	L00254	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:398: return with value
	LDB	-1,U		variable key, declared at /usr/local/share/cmoc/coco.h:383
	BRA	L00050		return (/usr/local/share/cmoc/coco.h:398)
L00254	EQU	*	else
* Useless label removed
* Useless label removed
	BRA	L00249	
* Useless label removed
L00050	EQU	*	end of waitkey()
	LEAS	,U	
	PULS	U,PC	


*******************************************************************************

* FUNCTION width(): defined at /usr/local/share/cmoc/coco.h:158
_width	EQU	*
	PSHS	U	
	LEAU	,S	
* Line /usr/local/share/cmoc/coco.h:160: if
	LDB	G00069+0,PCR	variable isCoCo3, declared at /usr/local/share/cmoc/coco.h:51
	TSTB
	BNE	L00257	
* optim: branchToNextLocation
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:161: return with value
	CLRA
	CLRB
	LBRA	L00040		return (/usr/local/share/cmoc/coco.h:161)
L00257	EQU	*	else
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:163: if
	LDB	5,U		variable columns
	CMPB	#$20	
	BEQ	L00260	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDB	5,U		variable columns
	CMPB	#$28	
	BEQ	L00260	
* optim: condBranchOverUncondBranch
* Useless label removed
	LDB	5,U		variable columns
	CMPB	#$50	
	BEQ	L00260	
* optim: condBranchOverUncondBranch
* Useless label removed
* Line /usr/local/share/cmoc/coco.h:164: return with value
	CLRA
	CLRB
	BRA	L00040		return (/usr/local/share/cmoc/coco.h:164)
L00260	EQU	*	else
* Useless label removed
	PSHS	U,Y		/usr/local/share/cmoc/coco.h:166: inline asm
	LDB	5,U		/usr/local/share/cmoc/coco.h:167: inline asm re: variable columns
	JSR	$F643		/usr/local/share/cmoc/coco.h:168: inline asm
	PULS	Y,U		/usr/local/share/cmoc/coco.h:169: inline asm
* Line /usr/local/share/cmoc/coco.h:171: assignment: =
	LDB	5,U	
	STB	G00070+0,PCR
* Line /usr/local/share/cmoc/coco.h:172: assignment: =
	LDB	5,U		variable columns
	CMPB	#$20	
	BEQ	L00264		if true
	CLRB
	BRA	L00265		false
L00264	EQU	*
	LDB	#1	
L00265	EQU	*
	CMPB	#0	
	BEQ	L00266		if conditional expression is false
	LDD	#$10		decimal 16 signed
	BRA	L00267		end of true expression of conditional
L00266	EQU	*
	LDD	#$18		decimal 24 signed
L00267	EQU	*
	STB	G00071+0,PCR
* Line /usr/local/share/cmoc/coco.h:174: return with value
	LDD	#$01		decimal 1 signed
* optim: branchToNextLocation
L00040	EQU	*	end of width()
	LEAS	,U	
	PULS	U,PC	
functions_end	EQU	*
string_literals_start	EQU	*


*******************************************************************************

* STRING LITERALS
S00075	EQU	*
	FCC	"PRESS ANY KEY TO CONTINUE... "
	FCB	0	
S00076	EQU	*
	FCC	"Press any key to continue... "
	FCB	0	
S00077	EQU	*
	FCC	"********************************"
	FCB	0	
S00078	EQU	*
	FCC	"*** WELCOME TO THE CMOC DEMO ***"
	FCB	0	
S00079	EQU	*
	FCC	"********************************"
	FCB	$0A	
	FCB	0	
S00080	EQU	*
	FCC	"*************************************"
	FCB	$0A	
	FCB	0	
S00081	EQU	*
	FCC	"*** CMOC Supports %u column text! ***"
	FCB	$0A	
	FCB	0	
S00082	EQU	*
	FCC	"*************************************"
	FCB	$0A	
	FCB	$0A	
	FCB	0	
S00083	EQU	*
	FCC	"With fancy attributes such as "
	FCB	0	
S00084	EQU	*
	FCC	"C"	
	FCB	0	
S00085	EQU	*
	FCC	"O"	
	FCB	0	
S00086	EQU	*
	FCC	"L"	
	FCB	0	
S00087	EQU	*
	FCC	"R"	
	FCB	0	
S00088	EQU	*
	FCC	","	
	FCB	$0A	
	FCB	0	
S00089	EQU	*
	FCC	"Underline"
	FCB	0	
S00090	EQU	*
	FCC	" and "	
	FCB	0	
S00091	EQU	*
	FCC	"Blink"	
	FCB	0	
S00092	EQU	*
	FCC	"!"	
	FCB	$0A	
	FCB	$0A	
	FCB	0	
S00093	EQU	*
	FCC	"Combine attributes like so... "
	FCB	0	
S00094	EQU	*
	FCC	"U"	
	FCB	0	
S00095	EQU	*
	FCC	"G"	
	FCB	0	
S00096	EQU	*
	FCC	"Y"	
	FCB	0	
S00097	EQU	*
	FCC	"!"	
	FCB	0	
S00098	EQU	*
	FCB	$0A	
	FCC	"But don't feel obligated to do that!"
	FCB	$0A	
	FCB	$0A	
	FCB	0	
S00099	EQU	*
	FCC	"*** BUBBLE SORT VERSUS QSORT ***"
	FCB	0	
S00100	EQU	*
	FCC	"PRESS A KEY TO SEE BUBBLE SORT "
	FCB	0	
S00101	EQU	*
	FCC	"PRESS A KEY TO SEE QSORT "
	FCB	0	
S00102	EQU	*
	FCC	"LOREM IPSUM DOLOR SIT AMET... "
	FCB	0	
S00103	EQU	*
	FCC	"THE QUICK BROWN FOX JUMPED OVER"
	FCB	$0A	
	FCB	0	
S00104	EQU	*
	FCC	"THE LAZY TYPIST"
	FCB	$0A	
	FCB	$0A	
	FCB	0	
S00105	EQU	*
	FCC	"***  HIRES GRAPHICS SCREENS  ***"
	FCB	0	
S00106	EQU	*
	FCC	"***    PLAY AWESOME SONGS    ***"
	FCB	0	
S00107	EQU	*
	FCC	"***   HAVE FUN USING CMOC!   ***"
	FCB	0	
string_literals_end	EQU	*


*******************************************************************************

* READ-ONLY GLOBAL VARIABLES


*******************************************************************************

* WRITABLE GLOBAL VARIABLES
* Globals with static initializers
G00072	EQU	*	data: unsigned char[]
	FCB	$7D		decimal 125
	FCB	$93		decimal 147
	FCB	$AA		decimal 170
	FCB	$93		decimal 147
	FCB	$8C		decimal 140
	FCB	$9F		decimal 159
	FCB	$B0		decimal 176
	FCB	$9F		decimal 159
	FCB	$93		decimal 147
	FCB	$AA		decimal 170
	FCB	$B9		decimal 185
	FCB	$AA		decimal 170
	FCB	$9F		decimal 159
	FCB	$B0		decimal 176
	FCB	$C1		decimal 193
	FCB	$B0		decimal 176
	FCB	$4E		decimal 78
	FCB	$75		decimal 117
	FCB	$8C		decimal 140
	FCB	$75		decimal 117
	FCB	$59		decimal 89
	FCB	$7D		decimal 125
	FCB	$93		decimal 147
	FCB	$7D		decimal 125
	FCB	$6C		decimal 108
	FCB	$8C		decimal 140
	FCB	$9F		decimal 159
	FCB	$8C		decimal 140
	FCB	$C1		decimal 193
	FCB	$CC		decimal 204
	FCB	$D8		decimal 216
	FCB	$CC		decimal 204
	FCB	$CC		decimal 204
	FCB	$C8		decimal 200
	FCB	$C1		decimal 193
	FCB	$B9		decimal 185
	FCB	$9F		decimal 159
	FCB	$AA		decimal 170
	FCB	$B0		decimal 176
	FCB	$B9		decimal 185
	FCB	$CC		decimal 204
	FCB	$C8		decimal 200
	FCB	$C1		decimal 193
	FCB	$CC		decimal 204
	FCB	$D2		decimal 210
	FCB	$CC		decimal 204
	FCB	$C8		decimal 200
	FCB	$D8		decimal 216
	FCB	$DA		decimal 218
	FCB	$D8		decimal 216
	FCB	$D2		decimal 210
	FCB	$CC		decimal 204
	FCB	$C8		decimal 200
	FCB	$CC		decimal 204
	FCB	$D2		decimal 210
	FCB	$D8		decimal 216
	FCB	$D2		decimal 210
	FCB	$CC		decimal 204
	FCB	$C8		decimal 200
	FCB	$C1		decimal 193
	FCB	$CC		decimal 204
	FCB	$C8		decimal 200
	FCB	$C1		decimal 193
	FCB	$B9		decimal 185
	FCB	$B0		decimal 176
	FCB	$93		decimal 147
	FCB	$7D		decimal 125
	FCB	$6C		decimal 108
	FCB	$59		decimal 89
	FCB	$7D		decimal 125
	FCB	$8C		decimal 140
	FCB	$93		decimal 147
	FCB	$9F		decimal 159
	FCB	$B0		decimal 176
	FCB	$AA		decimal 170
	FCB	$C1		decimal 193
	FCB	$B9		decimal 185
	FCB	$C8		decimal 200
	FCB	$D2		decimal 210
	FCB	$D8		decimal 216
	FCB	$DA		decimal 218
	FCB	$E3		decimal 227
	FCB	$E8		decimal 232
	FCB	$E7		decimal 231
	FCB	$E3		decimal 227
	FCB	$DA		decimal 218
	FCB	$DF		decimal 223
	FCB	$D2		decimal 210
	FCB	$CC		decimal 204
	FCB	$C1		decimal 193
	FCB	$B9		decimal 185
	FCB	$B0		decimal 176
	FCB	$AA		decimal 170
	FCB	$93		decimal 147
	FCB	$7D		decimal 125
	FCB	$59		decimal 89
	FCB	$00		decimal 0
* Uninitialized globals
G00069	EQU	*
	RMB	1		isCoCo3
G00070	EQU	*
	RMB	1		textScreenWidth
G00071	EQU	*
	RMB	1		textScreenHeight
G00073	EQU	*
	RMB	32		cd
G00074	EQU	*
	RMB	200		md


*******************************************************************************

#include "stdlib-data.inc"


*******************************************************************************

#include "stdlib.inc"


*******************************************************************************

* Initialize global variables.
INITGL	EQU	*
* Line /usr/local/share/cmoc/coco.h:51: init of variable isCoCo3
	CLR	G00069+0,PCR	variable isCoCo3
* Line /usr/local/share/cmoc/coco.h:152: init of variable textScreenWidth
	LDB	#$20		32
	STB	G00070+0,PCR	variable textScreenWidth
* Line /usr/local/share/cmoc/coco.h:153: init of variable textScreenHeight
	LDB	#$10		16
	STB	G00071+0,PCR	variable textScreenHeight
	RTS			end of global variable initialization


*******************************************************************************

program_end	EQU	*


*******************************************************************************

* WRITABLE DATA SECTION


*******************************************************************************

	END
